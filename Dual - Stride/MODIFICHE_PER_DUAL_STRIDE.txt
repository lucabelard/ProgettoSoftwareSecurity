# Elenco Modifiche per Conformit√† DUAL-STRIDE

Questo file riassume le modifiche raccomandate dal documento DUAL_STRIDE_ANALYSIS.md per migliorare la sicurezza e la robustezza del sistema "Oracolo Bayesiano per Catena del Freddo Farmaceutica". Le modifiche sono ordinate per priorit√†.

---
## üî¥ Priorit√† Alta (Da implementare subito)
---

### 1. Timeout e Recupero Fondi per Spedizioni Bloccate
**Problema**: I fondi (ETH) rimangono bloccati indefinitamente se un sensore si guasta e non invia mai tutte le evidenze necessarie.
**Soluzione**: Implementare una funzione `recuperaFondi` che permetta al mittente di annullare una spedizione e recuperare i fondi dopo un periodo di tempo predefinito (es. 7 giorni).

**Modifiche necessarie nel file `contracts/BNCalcolatoreOnChain.sol`**:
- Aggiungere una costante: `uint256 public constant TIMEOUT_GIORNI = 7;`
- Aggiornare l'enum `StatoSpedizione` aggiungendo lo stato `Annullata`.
- Aggiungere `uint256 dataCreazione;` alla `struct Spedizione`.
- Nella funzione `creaSpedizione`, salvare il timestamp: `s.dataCreazione = block.timestamp;`.
- Aggiungere un nuovo evento: `event SpedizioneAnnullata(uint256 indexed id, address indexed mittente, uint256 importoRimborsato);`.
- Creare la nuova funzione `recuperaFondi(uint256 _id)` che:
    - Controlla che il chiamante sia il mittente.
    - Controlla che la spedizione sia ancora 'InAttesa'.
    - Controlla che sia passato il `TIMEOUT_GIORNI`.
    - Controlla che NON tutte le evidenze siano state ricevute (per evitare abusi).
    - Cambia lo stato in 'Annullata', emette l'evento e rimborsa il mittente.

### 2. Guardia Anti-Reentrancy sul Pagamento
**Problema**: La funzione `validaEPaga` √® potenzialmente vulnerabile ad attacchi di reentrancy, che potrebbero consentire a un corriere malevolo di prelevare fondi pi√π volte.
**Soluzione**: Utilizzare la libreria `ReentrancyGuard` di OpenZeppelin, una soluzione standard del settore.

**Modifiche necessarie nel file `contracts/BNCalcolatoreOnChain.sol`**:
- Aggiungere l'import: `import "@openzeppelin/contracts/security/ReentrancyGuard.sol";`
- Far ereditare il contratto anche da `ReentrancyGuard`: `contract BNCalcolatoreOnChain is AccessControl, ReentrancyGuard { ... }`
- Aggiungere il modificatore `nonReentrant` alla funzione `validaEPaga`: `function validaEPaga(uint256 _id) external nonReentrant { ... }`

### 3. Governance Multi-Firma per Modifiche Critiche
**Problema**: Un singolo account (con `RUOLO_ORACOLO`) √® un Single Point of Failure. Se compromesso, pu√≤ manipolare le CPT e compromettere l'intero sistema.
**Soluzione**: Richiedere firme multiple per le operazioni critiche, in particolare `impostaCPT` e `impostaProbabilitaAPriori`.

**Modifiche raccomandate**:
- **Opzione A (On-chain)**: Utilizzare un `TimelockController` di OpenZeppelin. Le modifiche alle CPT devono essere proposte e passare attraverso un periodo di ritardo prima di diventare attive, dando tempo alla community di reagire.
- **Opzione B (Off-chain)**: Gestire il ruolo `RUOLO_ORACOLO` tramite un wallet multi-firma (es. Gnosis Safe). Qualsiasi transazione che chiama `impostaCPT` richieder√† l'approvazione di M-su-N proprietari del wallet.

---
## üü† Priorit√† Media (Da implementare a breve termine)
---

### 4. Validazione degli Input per le CPT
**Problema**: La funzione `impostaCPT` non valida che i valori inseriti siano compresi in un range logico (es. 0-100), aprendo a errori di configurazione.
**Soluzione**: Aggiungere dei `require` per controllare i valori.

**Modifiche necessarie nel file `contracts/BNCalcolatoreOnChain.sol`**:
- In `impostaCPT`, aggiungere controlli come: `require(_cpt.p_FF <= PRECISIONE, "Valore CPT invalido");` per tutti e quattro i parametri della struct CPT.

### 5. Eventi Dettagliati per il Monitoraggio
**Problema**: Mancano eventi per alcune azioni importanti, rendendo il monitoraggio e l'auditing pi√π difficili.
**Soluzione**: Emettere eventi per ogni cambiamento di stato critico.

**Modifiche necessarie nel file `contracts/BNCalcolatoreOnChain.sol`**:
- Aggiungere: `event EvidenzaInviata(uint256 indexed idSpedizione, uint8 indexed idEvidenza, bool valore, address indexed sensore);` da emettere in `inviaEvidenza`.
- Aggiungere: `event CPTModificata(uint8 indexed idEvidenza, address indexed oracolo);` da emettere in `impostaCPT`.

### 6. Importo Minimo per le Spedizioni
**Problema**: Un utente malintenzionato potrebbe creare migliaia di spedizioni con valore quasi nullo per intasare il sistema (attacco DoS/Spam).
**Soluzione**: Introdurre un importo minimo per la creazione di una spedizione.

**Modifiche necessarie nel file `contracts/BNCalcolatoreOnChain.sol`**:
- Aggiungere una costante: `uint256 public constant IMPORTO_MINIMO = 0.01 ether;` (o un valore simile).
- Nella funzione `creaSpedizione`, cambiare il `require` in: `require(msg.value >= IMPORTO_MINIMO, "Importo minimo non raggiunto");`.

---
## üü° Priorit√† Bassa (Lavori Futuri)
---

### 7. Protezione della Privacy dei Dati
**Problema**: I dati delle evidenze, sebbene booleani, sono pubblici sulla blockchain e potrebbero rivelare informazioni commerciali.
**Soluzione**: Esplorare l'uso di Zero-Knowledge Proofs (es. zk-SNARKs) per permettere la validazione della conformit√† senza rivelare le evidenze stesse.

### 8. Decentralizzazione degli Oracoli
**Problema**: I sensori fisici e gli account che li controllano sono ancora elementi centralizzati.
**Soluzione**: Valutare l'integrazione con un network di oracoli decentralizzato (es. Chainlink) per ottenere dati da fonti esterne in modo pi√π robusto e affidabile, specialmente per le evidenze pi√π critiche.

### 9. Piano di Risposta agli Incidenti
**Problema**: Non esiste un piano formale su come agire in caso di attacco.
**Soluzione**: Scrivere un "Incident Response Playbook" che definisca i passi da seguire per rilevare, contenere, eradicare e recuperare da un incidente di sicurezza. Implementare un meccanismo di pausa di emergenza (`Pausable` di OpenZeppelin).
