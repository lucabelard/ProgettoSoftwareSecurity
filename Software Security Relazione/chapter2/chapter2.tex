\chapter{Analisi e Progettazione Architetturale}

\begin{preamble}
In questo capitolo esploreremo le fondamenta tecnologiche ed architetturali che sostengono il sistema, analizzando le motivazioni profonde che hanno guidato ogni singola scelta progettuale. Non ci limiteremo a un elenco tecnico, ma giustificheremo l'adozione di strumenti come \textit{Hyperledger Besu}, la ridondanza dei nodi e l'uso di smart contract modulari alla luce di un'attenta analisi di sicurezza, focalizzata su resistenza, ambiguità e sopravvivenza.
\end{preamble}

\section{Scelte Tecnologiche e Infrastruttura Blockchain}

La pietra angolare del nostro sistema è rappresentata dalla scelta della piattaforma blockchain. Dopo un'attenta valutazione delle alternative, abbiamo optato per \textit{Hyperledger Besu} come client Ethereum per la nostra rete privata. Questa decisione non è casuale ma risponde a precise esigenze di \textit{enterprise security}. 

A differenza delle reti di sviluppo volatili come Ganache, Besu ci permette di simulare un ambiente di produzione realistico, supportando il protocollo di consenso \textit{IBFT 2.0} (Istanbul Byzantine Fault Tolerance). Questo meccanismo è cruciale per la nostra catena del freddo farmaceutica perché garantisce la \textit{finalità immediata} delle transazioni: una volta che un blocco è scritto, non può essere oggetto di "fork" o riorganizzazioni, assicurando che lo storico della temperatura di un farmaco non possa mai essere alterato o cancellato.

La nostra infrastruttura non si basa su un singolo nodo, che rappresenterebbe un pericoloso \textit{Single Point of Failure}, ma su una rete distribuita e ridondante composta da \textit{quattro nodi validatori} interconnessi. Per gestire efficacemente le richieste provenienti dall'interfaccia utente e garantire la continuità del servizio, abbiamo implementato un \textit{Proxy Inverso} (basato su Nginx) che si interpone tra il mondo esterno e la rete blockchain. Questo proxy non solo bilancia il carico, ma gestisce il \textit{failover} automatico: se uno dei nodi dovesse andare offline per un guasto o un attacco, il traffico verrebbe immediatamente reindirizzato verso i nodi rimanenti, rendendo il disservizio trasparente per l'utente finale.

A livello applicativo, la logica è scritta in \textit{Solidity 0.8.19}. Abbiamo scelto questa versione specifica per beneficiare delle protezioni native contro gli \textit{overflow/underflow} aritmetici, che nelle versioni precedenti richiedevano librerie esterne come SafeMath. Per garantire la massima robustezza, ci siamo affidati agli standard di sicurezza di \textit{OpenZeppelin} per la gestione dei ruoli e dei permessi, evitando di "reinventare la ruota" in componenti critici dove un errore potrebbe costare caro.

\section{Architettura On-Chain e Off-Chain}

L'architettura del sistema è stata progettata seguendo una rigorosa separazione delle responsabilità, distinguendo chiaramente tra ciò che deve vivere sulla blockchain (On-Chain) e ciò che invece risiede all'esterno (Off-Chain).

La parte \textit{On-Chain} è strutturata in tre livelli gerarchici di smart contract, ognuno con un compito ben definito per isolare la complessità e minimizzare la superficie di attacco. Alla base troviamo \textit{BNCore}, il "cervello" matematico che contiene la Rete Bayesiana e le tabelle di probabilità condizionata; questo contratto è puro calcolo e non gestisce fondi. Sopra di esso opera \textit{BNGestoreSpedizioni}, che si occupa del ciclo di vita della spedizione e della raccolta delle evidenze dai sensori. Infine, al vertice, \textit{BNPagamenti} gestisce la logica finanziaria e i trasferimenti di Ether, interagendo con gli altri due livelli. Questa modularità garantisce che un eventuale bug nella logica di business non comprometta necessariamente i fondi o l'integrità del modello matematico.

Il mondo \textit{Off-Chain}, invece, è composto dall'interfaccia utente web e dal middleware oracolo. L'interfaccia, realizzata con tecnologie web standard e la libreria \textit{Web3.js}, permette agli utenti di interagire con la blockchain senza dover comprendere la complessità sottostante. Il componente più critico è però il middleware \textit{simula\_oracolo.js}, un ponte essenziale che colma il divario tra i sensori fisici e la blockchain. Poiché gli smart contract non possono accedere autonomamente ai dati del mondo reale, questo script simula l'acquisizione dati da cinque sensori IoT distinti (temperatura, umidità, shock, luce, sigillo) e invia le letture alla blockchain sotto forma di transazioni firmate digitalmente.

\section{Motivazioni alla Luce dell'Analisi di Sicurezza}

Ogni scelta tecnologica descritta sopra trova la sua giustificazione nelle analisi di sicurezza condotte durante la fase di design.

\subsection{Analisi di Resistenza}
La \textit{resistenza} del sistema agli attacchi è il primo pilastro della nostra strategia difensiva.
Contro i tentativi di \textit{tampering} (manomissione dati), la natura immutabile della blockchain Hyperledger Besu offre una garanzia assoluta: ogni lettura dei sensori, una volta minata in un blocco, diventa inalterabile.
Per contrastare lo \textit{spoofing} (furto di identità), l'utilizzo di \textit{OpenZeppelin AccessControl} assicura che solo gli attori in possesso delle chiavi crittografiche corrette e del ruolo \textit{RUOLO\_SENSORE} possano scrivere dati sul ledger.
Infine, la resistenza agli attacchi \textit{Denial of Service} (DDoS) è intrinseca nella nostra architettura distribuita: con quattro nodi e un consenso IBFT che tollera fino a un terzo di nodi bizantini (o offline), un attaccante dovrebbe compromettere simultaneamente più macchine per bloccare il servizio, un'impresa decisamente più ardua rispetto al colpire un database centralizzato.

\subsection{Analisi di Ambiguità}
L'\textit{ambiguità}, intesa come capacità di nascondere informazioni sensibili senza perdere la verificabilità, è stata affrontata con un approccio di "Privacy by Design".
I dati commerciali sensibili, come i dettagli specifici della merce trasportata o l'identità dei clienti, non vengono mai memorizzati in chiaro sulla blockchain pubblica. Al loro posto, registriamo solamente un \textit{hash crittografico} (impronta digitale) dei dati. Questo permette alle parti autorizzate di verificare l'integrità delle informazioni Off-Chain confrontandole con l'hash On-Chain, mentre per un osservatore esterno il contenuto rimane completamente indecifrabile.
Inoltre, applichiamo un offuscamento logico alla Rete Bayesiana stessa: mentre il risultato finale della valutazione (la probabilità di conformità) è pubblico, le Tabelle di Probabilità Condizionata (CPT) interne sono mantenute private all'interno dello smart contract. Questo impedisce a un attaccante di fare \textit{reverse engineering} completo del modello decisionale per studiare come ingannarlo "al limite" della soglia.

\subsection{Analisi di Sopravvivenza}
La \textit{sopravvivenza}, o resilienza, è la capacità del sistema di continuare a operare anche in presenza di guasti parziali.
La nostra scelta di implementare una ridondanza a tutti i livelli è la risposta a questa esigenza. Non ci affidiamo a un solo sensore, ma a cinque diversi tipi di input; il sistema è progettato per funzionare (seppur in modalità degradata o con incertezza maggiore) anche se uno o due sensori smettono di trasmettere.
A livello infrastrutturale, la configurazione a quattro nodi Besu gestita dal proxy garantisce che il fallimento di un nodo non fermi la blockchain. Il protocollo di consenso continua a produrre blocchi finché esiste una maggioranza qualificata di nodi attivi. Questa architettura assicura che il dato critico sulla temperatura non vada perso nemmeno nello scenario peggiore di un guasto hardware al server principale.

\section{Motivazioni alla Luce dell'Analisi delle Debolezze}

Nessuna tecnologia è perfetta, e la nostra analisi ha identificato alcune debolezze intrinseche che abbiamo mitigato con scelte specifiche.

Una debolezza nota di Ethereum è il costo imprevedibile delle transazioni (\textit{Gas Cost}). Per mitigare questo rischio in un contesto enterprise, la scelta di una rete privata \textit{Hyperledger Besu} ci permette di azzerare i costi del gas o di mantenerli costanti, svincolandoci dalla volatilità della mainnet pubblica.
Un'altra criticità è l'\textit{immutabilità del codice}: un bug in uno smart contract distribuito è per sempre. Per mitigare questo rischio, abbiamo adottato una strategia di testing profonda, utilizzando \textit{Truffle} per unit test esaustivi e la verifica formale con \textit{PRISM} per dimostrare matematicamente la correttezza delle proprietà di sicurezza prima del deployment.
Infine, il cosiddetto \textit{"Problema dell'Oracolo"} (la blockchain si fida ciecamente dei dati esterni) rappresenta una vulnerabilità strutturale. La nostra risposta è stata la ridondanza dei sensori: non fidandoci di una singola fonte di verità, incrociamo i dati di cinque diversi dispositivi attraverso la Rete Bayesiana, rendendo molto più difficile per un attaccante o un guasto isolato compromettere la validità della decisione finale.

\section{Design degli Asset e Linee Guida di Sicurezza}

La progettazione degli asset del sistema non è stata lasciata al caso, ma ha seguito rigorosamente le best practice e i principi di sicurezza consolidati in letteratura, con particolare riferimento alle linee guida di \textit{Saltzer \& Schroeder} e \textit{OWASP}.

In primo luogo, abbiamo applicato il principio di \textit{Economy of Mechanism} (Semplicità del Meccanismo), mantenendo la logica degli smart contract quanto più essenziale possibile. Separando la logica di calcolo (BNCore) da quella di gestione (BNGestoreSpedizioni), abbiamo ridotto la complessità di ogni singolo componente, facilitandone l'audit e riducendo la probabilità di bug nascosti.

Il principio di \textit{Fail-Safe Defaults} (Default Sicuri) permea l'intero sistema di controllo degli accessi: in assenza di permessi espliciti, ogni operazione è negata di default. Grazie all'utilizzo della libreria \textit{OpenZeppelin AccessControl}, ogni funzione critica (come la validazione o il pagamento) verifica preventivamente che il chiamante possieda il ruolo necessario, bloccando immediatamente qualsiasi tentativo non autorizzato.

Infine, il principio di \textit{Least Privilege} (Minimo Privilegio) assicura che ogni attore o componente disponga solo dei permessi strettamente necessari per svolgere il proprio compito. L'oracolo, ad esempio, può inviare dati ma non può sbloccare fondi; l'amministratore può configurare i parametri del sistema ma non può alterare arbitrariamente lo stato di una spedizione in corso. Questo isolamento limita drasticamente i danni potenziali in caso di compromissione di un singolo account.

\section{Modellazione Markov Chain e Verifica Formale con PRISM}

Per garantire matematicamente la robustezza del sistema e validare le contromisure di sicurezza, abbiamo adottato un approccio di \textit{Probabilistic Model Checking} utilizzando il tool \textit{PRISM 4.9}. L'unità critica del processo di Escrow e Pagamenti è stata modellata come una \textit{Catena di Markov a Tempo Discreto (DTMC)}, dove l'evoluzione futura del sistema dipende esclusivamente dallo stato presente e dalle probabilità di transizione definite dal protocollo.

Il modello implementato riflette fedelmente la macchina a stati finiti definita nello smart contract \texttt{BNGestoreSpedizioni.sol}, mappando i quattro macro-stati fondamentali del ciclo di vita di una spedizione:

\begin{itemize}
    \item \textbf{InAttesa (0)}: Stato iniziale transitorio. La spedizione è stata creata e attende le evidenze dai sensori o lo scadere del timeout. Da qui, il sistema può evolvere verso il successo (Pagata) o il fallimento (Rimborsata/Annullata).
    \item \textbf{Pagata (1)}: Stato assorbente positivo. La validazione bayesiana ha avuto successo (probabilità stimata $\approx 60\%$) e i fondi sono stati trasferiti al corriere.
    \item \textbf{Annullata (2)}: Stato assorbente negativo. Il mittente ha annullato la spedizione prima dell'invio di qualsiasi evidenza (probabilità $\approx 5\%$).
    \item \textbf{Rimborsata (3)}: Stato assorbente di recovery. Include i casi di rimborso per timeout (dopo 7 giorni, $\approx 10\%$) o per fallimento della validazione (merce non conforme, $\approx 25\%$).
\end{itemize}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=\linewidth, keepaspectratio]{chapter2/image/Grafico_Markov_Chain.png}
    \caption{Modello DTMC del Sistema di Escrow e Transizioni di Stato}
    \label{fig:markov_chain}
\end{figure}

L'analisi formale ci ha permesso di verificare due classi di proprietà critiche, espresse nel linguaggio \textit{PCTL (Probabilistic Computation Tree Logic)}, che confermano la resistenza del design alle minacce identificate nell'analisi DUAL-STRIDE:

\subsection{Proprietà di Safety: Single Payment}
Abbiamo verificato che sia matematicamente \textit{impossibile} per il sistema effettuare doppi pagamenti o uscire dallo stato di pagamento una volta raggiunto, mitigando definitivamente il rischio di attacchi \textit{Reentrancy} (Minaccia T3.1-A). La proprietà verificata è:
\begin{center}
\texttt{filter(forall, stato=1 => P>=1 [ X stato=1 ])}
\end{center}
\textbf{Risultato:} Il model checker ha confermato che questa proprietà è valida con probabilità \textbf{1.0 (100\%)}. Ciò dimostra che lo stato \textit{Pagata} è strettamente assorbente: una volta che i fondi sono trasferiti, la transazione è immutabile e irreversibile.

\subsection{Proprietà di Guarantee: Rimborso per Timeout}
Abbiamo inoltre verificato che il sistema garantisca il rimborso al mittente qualora la validazione non avvenga entro i limiti temporali, proteggendo i fondi da blocchi accidentali (Minaccia D3.1-M) o attacchi di tipo \textit{Withholding} (Minaccia D3.1-A). La proprietà analizzata misura la probabilità minima di rimborso allo scadere del timeout:
\begin{center}
\texttt{filter(min, P=? [ F stato=3 ], stato=0 \& timeout\_scaduto)}
\end{center}
\textbf{Risultato:} L'analisi ha restituito una probabilità garantita superiore al \textbf{95\%}. Questo certifica che il meccanismo di \textit{Escrow} offre una "Safety Exit" affidabile: in caso di stallo del protocollo o malfunzionamento dei sensori, l'utente ha la quasi certezza matematica di recuperare i propri fondi, rendendo il sistema resiliente (Survivable) anche in condizioni avverse.
