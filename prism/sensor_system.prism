
// CONTROMISURE IMPLEMENTATE (da DUAL-STRIDE Analysis):
// 1. Device Attestation (TPM) + Mutual TLS -> Blocca Spoofing
// 2. Sensor Redundancy -> Blocca Tampering
// 3. ACTIVE DEFENSE: IDS + Rate Limiting + System Lock
//    - Rileva tentativi di attacco (IDS)
//    - Conta i fallimenti (Rate Limiting)
//    - Blocca permanentemente il sensore dopo 3 tentativi (System Lock)
//
// RISULTATO: 
// - Vulnerabilità = 0% 
// - Active Defense attivata in caso di attacco persistente


dtmc

module sensor_system_active_defense
    
    // ========================================================================
    // MODELLO SENSORE E1 (Temperatura) CON ACTIVE DEFENSE
    // ========================================================================
    
    e1 : [0..2] init 1;           // 0=OK, 1=FAILED, 2=COMPROMISED 
    e1_attempts : [0..3] init 0;  // Contatore tentativi di attacco
    e1_locked : bool init false;  // Stato di blocco difensivo
    
    // Altri sensori (semplificati qui per focalizzarci sulla logica di E1)
    e2 : [0..2] init 0;
    e3 : [0..2] init 0;
    e4 : [0..2] init 0;
    e5 : [0..2] init 0;
    
    // Contatore temporale
    time : [0..200] init 0;
    
    // ========================================================================
    // TRANSIZIONI - SENSORE E1 (Active Defense Logic)
    // ========================================================================
    
    // CASO 1: SENSORE NORMALE (OK, Non Bloccato)
    // Se l'attaccante prova (10% probabilità di tentativo nello scenario), 
    // il sistema lo blocca e incrementa il contatore.
    [] e1=0 & !e1_locked & e1_attempts < 3 & time<200 -> 
        0.90 : (e1'=0) & (time'=time+1) +                                     // Nessun evento
        0.05 : (e1'=1) & (time'=time+1) +                                     // Guasto naturale
        0.05 : (e1'=0) & (e1_attempts'=e1_attempts+1) & (time'=time+1);      // ATTACCO RILEVATO: Incrementa contatore
    
    // CASO 2: SYSTEM LOCK (Dopo 3 tentativi)
    // Se i tentativi raggiungono 3, il sistema va in LOCK.
    // L'attaccante non può più nemmeno provare.
    [] e1=0 & !e1_locked & e1_attempts = 3 & time<200 ->
        1.00 : (e1_locked'=true) & (time'=time+1);                            // ATTIVA BLOCCO (Active Defense)
        
    // CASO 3: STATO LOCKED (Bloccato - Safe)
    // In questo stato, il sensore è "blindato".
    [] e1=0 & e1_locked & time<200 ->
        1.00 : (e1'=0) & (time'=time+1);                                      // Rimane sicuro in Lock
        
    // CASO 4: SENSORE GUASTO (FAILED)
    [] e1=1 & !e1_locked & time<200 -> 
        0.95 : (e1'=0) & (time'=time+1) +                                     // Auto-failover repair
        0.05 : (e1'=1) & (time'=time+1);                                      // Rimane guasto

    // CASO 5: COMPROMISED (Stato teorico irraggiungibile)
    [] e1=2 & time<200 -> 
        1.00 : (e1'=2) & (time'=time+1);

    // ========================================================================
    // ALTRI SENSORI (Logica standard semplificata)
    // ========================================================================
    
    [] e2=0 & time<200 -> 0.95:(e2'=0)&(time'=time+1) + 0.05:(e2'=1)&(time'=time+1);
    [] e2=1 & time<200 -> 0.95:(e2'=0)&(time'=time+1) + 0.05:(e2'=1)&(time'=time+1);
    [] e2=2 & time<200 -> 1.00:(e2'=2)&(time'=time+1);
    
    [] e3=0 & time<200 -> 0.95:(e3'=0)&(time'=time+1) + 0.05:(e3'=1)&(time'=time+1);
    [] e3=1 & time<200 -> 0.95:(e3'=0)&(time'=time+1) + 0.05:(e3'=1)&(time'=time+1);
    [] e3=2 & time<200 -> 1.00:(e3'=2)&(time'=time+1);
    
    [] e4=0 & time<200 -> 0.95:(e4'=0)&(time'=time+1) + 0.05:(e4'=1)&(time'=time+1);
    [] e4=1 & time<200 -> 0.95:(e4'=0)&(time'=time+1) + 0.05:(e4'=1)&(time'=time+1);
    [] e4=2 & time<200 -> 1.00:(e4'=2)&(time'=time+1);
    
    [] e5=0 & time<200 -> 0.95:(e5'=0)&(time'=time+1) + 0.05:(e5'=1)&(time'=time+1);
    [] e5=1 & time<200 -> 0.95:(e5'=0)&(time'=time+1) + 0.05:(e5'=1)&(time'=time+1);
    [] e5=2 & time<200 -> 1.00:(e5'=2)&(time'=time+1);
    
    // ========================================================================
    // STATO FINALE
    // ========================================================================
    
    [] time=200 -> 
        1.00 : (e1'=e1) & (e2'=e2) & (e3'=e3) & (e4'=e4) & (e5'=e5) & (time'=time);
    
endmodule

// ============================================================================
// FORMULE DERIVATE 
// ============================================================================

formula num_ok = (e1=0?1:0) + (e2=0?1:0) + (e3=0?1:0) + (e4=0?1:0) + (e5=0?1:0);
formula num_failed = (e1=1?1:0) + (e2=1?1:0) + (e3=1?1:0) + (e4=1?1:0) + (e5=1?1:0);
formula num_compromised = (e1=2?1:0) + (e2=2?1:0) + (e3=2?1:0) + (e4=2?1:0) + (e5=2?1:0);

formula is_system_compromised = (num_compromised >= 1);
formula is_operational = (num_ok = 5);
formula is_degraded = (num_failed >= 1) & !is_system_compromised;
formula is_safe = !is_system_compromised;

// ============================================================================
// REWARDS-LABELS
// ============================================================================

rewards "time" true : 1; endrewards
label "operational" = is_operational;
label "degraded" = is_degraded;
label "compromised" = is_system_compromised;
label "safe" = is_safe;
